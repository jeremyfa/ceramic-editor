<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
    <style>
        html, body {
            background-color: #1E1E1E;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #container {
            background-color: #1E1E1E;
            display: block;
            position: relative;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

<div id="container"></div>

<script src="monaco-editor/min/vs/loader.js"></script>
<script>
    var didInitMonaco = false;
    var editor = null;
    function initMonaco(
        content,
        extraLibs,
        log,
        emitChange,
        emitSave,
        emitSaveAs,
        emitUndo,
        emitRedo,
        emitPlay
    ) {
        if (didInitMonaco) return;
        didInitMonaco = true;
        
        require.config({ paths: { 'vs': 'monaco-editor/min/vs' }});
        require(['vs/editor/editor.main'], function() {
            // validation settings
            monaco.languages.typescript.javascriptDefaults.setDiagnosticsOptions({
                noSemanticValidation: false,
                noSyntaxValidation: true,
                noSuggestionDiagnostics: true,
                diagnosticCodesToIgnore: [
                    2318, // Cannot find global type A.
                    2405, // The left-hand side of a 'for...in' statement must be of type A or 'any'..
                    2304, // Cannot find name A.
                    2552, // Cannot find name 'qua'. Did you mean 'quad'?
                    2582, // Cannot find name 'test'. Do you need to install type definitions for a test runner?
                    2407, // The right-hand side of a 'for...in' statement must be of type A or 'any'..
                    2339, // Property A does not exist on type B.
                    1108 // A 'return' statement can only be used within a function body.
                ]
            });
            // extra libraries
            if (extraLibs) {
                for (i = 0; i < extraLibs.length; i++) {
                    monaco.languages.typescript.javascriptDefaults.addExtraLib(extraLibs[i]);
                }
            }
            // compiler options
            monaco.languages.typescript.javascriptDefaults.setCompilerOptions({
                noLib: true,
                target: monaco.languages.typescript.ScriptTarget.ES6,
                allowNonTsExtensions: true
            });
            editor = monaco.editor.create(document.getElementById('container'), {
                value: content,
                language: 'javascript',
                automaticLayout: true,
                wordWrap: true,
                minimap: {
                    enabled : false
                },
                theme: "vs-dark"
            });

            editor.addAction({
                id: 'save',
                label: 'Save',
                keybindings: [
                    monaco.KeyMod.chord(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_S)
                ],
                run: function(ed) {
                    emitSave();
                    return null;
                }
            });

            editor.addAction({
                id: 'save-as',
                label: 'Save As',
                keybindings: [
                    monaco.KeyMod.chord(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_S)
                ],
                run: function(ed) {
                    emitSaveAs();
                    return null;
                }
            });

            var didUndoOrRedo = false;

            editor.addAction({
                id: 'undo',
                label: 'Undo',
                keybindings: [
                    monaco.KeyMod.chord(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_Z)
                ],
                run: function(ed) {
                    didUndoOrRedo = true;
                    emitUndo();
                    editor.getModel().undo();
                    return null;
                }
            });

            editor.addAction({
                id: 'redo',
                label: 'Redo',
                keybindings: [
                    monaco.KeyMod.chord(monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_Z)
                ],
                run: function(ed) {
                    didUndoOrRedo = true;
                    emitRedo();
                    editor.getModel().redo();
                    return null;
                }
            });

            editor.addAction({
                id: 'play',
                label: 'Play',
                keybindings: [
                    monaco.KeyMod.chord(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter)
                ],
                run: function(ed) {
                    emitPlay();
                    return null;
                }
            });

            var shouldSubmitChanges = false;
            editor.getModel().onDidChangeContent(function(e) {
                shouldSubmitChanges = true;
            });

            setInterval(function() {
                if (shouldSubmitChanges) {
                    shouldSubmitChanges = false;
                    emitChange(editor.getModel().getLinesContent(), didUndoOrRedo);
                    didUndoOrRedo = false;
                }
            }, 500);
        });
    }
    function setEditorContent(content) {
        if (editor == null) {
            setTimeout(function() {
                setEditorContent(content);
            }, 100);
            return;
        }

        editor.getModel().setValue(content);
    }
</script>
</body>
</html>